const axios = require('axios');
const https = require('https');
const { exec } = require('child_process');
const util = require('util');
const execPromise = util.promisify(exec);
const dns = require('dns').promises;
const whois = require('whois-json');
const aiService = require('./aiService');

function parseUrl(url) {
  try {
    const u = new URL(url);
    return { hostname: u.hostname };
  } catch (e) {
    return { hostname: null, error: 'Invalid URL' };
  }
}

// Mock SSL class as a replacement for node-ssl-scan
class MockSSL {
  async scan(url) {
    console.log(`[Mock] Scanning SSL for ${url}`);
    return {
      valid: true,
      issuer: "Mock Certificate Authority",
      validFrom: new Date(),
      validTo: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000), // Valid for 1 year
      protocol: "TLSv1.3",
      cipher: "ECDHE-RSA-AES256-GCM-SHA384",
      chain: ["Mock Root CA", "Mock Intermediate CA"],
      vulnerabilities: []
    };
  }
}

class VulnerabilityScanner {
  constructor() {
    this.sslScanner = new MockSSL();
    this.scanHistory = new Map();
  }

  async analyzeWithAI(data, context) {
    try {
      const prompt = `Analyze the following security data and provide a detailed assessment:
        Context: ${context}
        Data: ${JSON.stringify(data, null, 2)}
        
        Please provide:
        1. Risk assessment
        2. Potential vulnerabilities
        3. Security recommendations
        4. Severity level (critical, high, medium, low)`;

      const result = await this.model.generateContent(prompt);
      const response = await result.response;
      return response.text();
    } catch (error) {
      console.error('AI analysis error:', error);
      return null;
    }
  }

  async scan(url, scanType) {
    try {
      const startTime = Date.now();
      const results = {
        metadata: {
          url,
          scanType,
          timestamp: new Date().toISOString(),
          scanDuration: '0s'
        },
        summary: {
          score: 0,
          totalIssues: 0,
          criticalIssues: 0,
          highIssues: 0,
          mediumIssues: 0,
          lowIssues: 0
        },
        details: {}
      };

      // Perform all scan types
      const [dnsInfo, whoisInfo, sslInfo, headersInfo, portsInfo, vulnInfo] = await Promise.all([
        this.performDNSAnalysis(url),
        this.performWhoisLookup(url),
        this.performSSLScan(url),
        this.checkSecurityHeaders(url),
        this.scanOpenPorts(url),
        this.performVulnerabilityScan(url)
      ]);

      results.details = {
        dns: dnsInfo,
        whois: whoisInfo,
        ssl: sslInfo,
        headers: headersInfo,
        ports: portsInfo,
        vulnerabilities: vulnInfo
      };

      // Get AI analysis for the scan results
      const aiAnalysis = await aiService.analyzeSecurityData(results.details, 'Website Security Scan');
      results.aiAnalysis = aiAnalysis;

      // Predict potential threats
      const historicalData = this.scanHistory.get(url) || [];
      const threatPrediction = await aiService.predictThreats(historicalData, results.details);
      results.threatPrediction = threatPrediction;

      // Calculate overall score
      results.summary = this.calculateScore(results.details);

      // Update scan duration
      results.metadata.scanDuration = `${((Date.now() - startTime) / 1000).toFixed(1)}s`;

      // Store in history
      this.scanHistory.set(url, [...historicalData, results]);

      return results;
    } catch (error) {
      console.error('Scan error:', error);
      throw error;
    }
  }

  async performDNSAnalysis(url) {
    const { hostname } = parseUrl(url);
    try {
      const [aRecords, mxRecords, txtRecords] = await Promise.all([
        dns.resolve(hostname, 'A'),
        dns.resolve(hostname, 'MX').catch(() => []),
        dns.resolve(hostname, 'TXT').catch(() => [])
      ]);

      return {
        aRecords,
        mxRecords,
        txtRecords,
        spfRecord: txtRecords.find(record => record[0].startsWith('v=spf1')),
        dkimRecord: txtRecords.find(record => record[0].startsWith('v=DKIM1')),
        dmarcRecord: txtRecords.find(record => record[0].startsWith('v=DMARC1'))
      };
    } catch (error) {
      console.error('DNS analysis error:', error);
      return { error: error.message };
    }
  }

  async performWhoisLookup(url) {
    const { hostname } = parseUrl(url);
    try {
      const whoisData = await whois(hostname);
      return {
        registrar: whoisData.registrar,
        creationDate: whoisData.creationDate,
        expirationDate: whoisData.expirationDate,
        nameServers: whoisData.nameServers,
        status: whoisData.status
      };
    } catch (error) {
      console.error('Whois lookup error:', error);
      return { error: error.message };
    }
  }

  async performSSLScan(url) {
    try {
      const sslResults = await this.sslScanner.scan(url);
      return {
        valid: sslResults.valid,
        issuer: sslResults.issuer,
        validFrom: sslResults.validFrom,
        validTo: sslResults.validTo,
        protocol: sslResults.protocol,
        cipher: sslResults.cipher,
        certificateChain: sslResults.chain,
        vulnerabilities: sslResults.vulnerabilities || []
      };
    } catch (error) {
      console.error('SSL scan error:', error);
      return { error: error.message };
    }
  }

  async checkSecurityHeaders(url) {
    try {
      const response = await axios.get(url);
      const headers = response.headers;
      const requiredHeaders = [
        'Strict-Transport-Security',
        'X-Content-Type-Options',
        'X-Frame-Options',
        'X-XSS-Protection',
        'Content-Security-Policy',
        'Referrer-Policy',
        'Permissions-Policy',
        'Cross-Origin-Opener-Policy',
        'Cross-Origin-Embedder-Policy',
        'Cross-Origin-Resource-Policy'
      ];

      const headerAnalysis = requiredHeaders.map(header => ({
        name: header,
        present: !!headers[header],
        value: headers[header] || null,
        recommended: this.getRecommendedHeaderValue(header)
      }));

      return {
        headers: headerAnalysis,
        score: this.calculateHeaderScore(headerAnalysis)
      };
    } catch (error) {
      console.error('Header check error:', error);
      return { error: error.message };
    }
  }

  async scanOpenPorts(url) {
    const { hostname } = parseUrl(url);
    try {
      const { stdout } = await execPromise(`nmap -p 1-1000 -sV ${hostname}`);
      const ports = stdout
        .split('\n')
        .filter(line => line.includes('open'))
        .map(line => {
          const [port, state, service, version] = line.split(/\s+/);
          return { port, state, service, version };
        });

      return {
        ports,
        commonVulnerabilities: this.checkCommonPortVulnerabilities(ports)
      };
    } catch (error) {
      if (error.stderr && error.stderr.includes('not recognized')) {
        return { error: 'nmap is not installed on the server.' };
      }
      return { error: error.message };
    }
  }

  async performVulnerabilityScan(url) {
    const vulnerabilities = [];
    
    // Check for common vulnerabilities
    const checks = [
      this.checkXSSVulnerability(url),
      this.checkSQLInjection(url),
      this.checkCSRFVulnerability(url),
      this.checkFileInclusion(url),
      this.checkCommandInjection(url),
      this.checkXXEVulnerability(url)
    ];

    const results = await Promise.all(checks);
    
    // Get AI analysis for each vulnerability
    for (const result of results) {
      if (result.vulnerable) {
        const aiAnalysis = await this.analyzeWithAI(result, 'Vulnerability Analysis');
        result.aiAnalysis = aiAnalysis;
        vulnerabilities.push(result);
      }
    }

    return vulnerabilities;
  }

  calculateScore(details) {
    let score = 100;
    const issues = {
      critical: 0,
      high: 0,
      medium: 0,
      low: 0
    };

    // SSL Score
    if (details.ssl.error || !details.ssl.valid) {
      score -= 20;
      issues.critical++;
    }

    // Headers Score
    if (details.headers.score) {
      score -= (100 - details.headers.score) / 5;
      if (details.headers.score < 60) issues.high++;
      else if (details.headers.score < 80) issues.medium++;
    }

    // Ports Score
    if (details.ports.commonVulnerabilities?.length > 0) {
      score -= details.ports.commonVulnerabilities.length * 5;
      issues.high += details.ports.commonVulnerabilities.length;
    }

    // Vulnerabilities Score
    details.vulnerabilities.forEach(vuln => {
      switch (vuln.severity) {
        case 'critical':
          score -= 20;
          issues.critical++;
          break;
        case 'high':
          score -= 15;
          issues.high++;
          break;
        case 'medium':
          score -= 10;
          issues.medium++;
          break;
        case 'low':
          score -= 5;
          issues.low++;
          break;
      }
    });

    return {
      score: Math.max(0, Math.round(score)),
      totalIssues: Object.values(issues).reduce((a, b) => a + b, 0),
      ...issues
    };
  }

  getRecommendedHeaderValue(header) {
    const recommendations = {
      'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
      'X-Content-Type-Options': 'nosniff',
      'X-Frame-Options': 'SAMEORIGIN',
      'X-XSS-Protection': '1; mode=block',
      'Content-Security-Policy': "default-src 'self'",
      'Referrer-Policy': 'strict-origin-when-cross-origin',
      'Permissions-Policy': 'geolocation=(), microphone=(), camera=()',
      'Cross-Origin-Opener-Policy': 'same-origin',
      'Cross-Origin-Embedder-Policy': 'require-corp',
      'Cross-Origin-Resource-Policy': 'same-origin'
    };
    return recommendations[header];
  }

  calculateHeaderScore(headerAnalysis) {
    const totalHeaders = headerAnalysis.length;
    const presentHeaders = headerAnalysis.filter(h => h.present).length;
    return Math.round((presentHeaders / totalHeaders) * 100);
  }

  checkCommonPortVulnerabilities(ports) {
    const vulnerabilities = [];
    const commonVulnPorts = {
      21: 'FTP - Consider using SFTP instead',
      23: 'Telnet - Insecure protocol, should be disabled',
      25: 'SMTP - Ensure proper authentication is required',
      445: 'SMB - Ensure latest version and proper authentication',
      1433: 'MSSQL - Ensure proper authentication and encryption',
      3306: 'MySQL - Ensure proper authentication and encryption',
      3389: 'RDP - Ensure proper authentication and encryption'
    };

    ports.forEach(port => {
      if (commonVulnPorts[port.port]) {
        vulnerabilities.push({
          port: port.port,
          service: port.service,
          risk: 'high',
          recommendation: commonVulnPorts[port.port]
        });
      }
    });

    return vulnerabilities;
  }

  // Vulnerability check methods
  async checkXSSVulnerability(url) {
    try {
      const response = await axios.get(url);
      const content = response.data;
      
      // Basic XSS check
      const xssPatterns = [
        '<script>',
        'javascript:',
        'onerror=',
        'onload=',
        'eval(',
        'document.cookie'
      ];

      const findings = xssPatterns.filter(pattern => 
        content.toLowerCase().includes(pattern.toLowerCase())
      );

      const result = {
        type: 'XSS',
        severity: findings.length > 0 ? 'high' : 'low',
        description: findings.length > 0 
          ? 'Potential cross-site scripting vulnerability detected'
          : 'No obvious XSS vulnerabilities found',
        evidence: findings.length > 0 
          ? `Found ${findings.length} potential XSS patterns`
          : 'No suspicious patterns found',
        recommendation: 'Implement proper input validation and output encoding',
        vulnerable: findings.length > 0
      };

      // Get AI analysis for XSS findings
      if (findings.length > 0) {
        result.aiAnalysis = await this.analyzeWithAI({
          patterns: findings,
          content: content.substring(0, 1000) // Send first 1000 chars for analysis
        }, 'XSS Vulnerability Analysis');
      }

      return result;
    } catch (error) {
      console.error('XSS check error:', error);
      return {
        type: 'XSS',
        severity: 'unknown',
        description: 'Error during XSS check',
        evidence: error.message,
        recommendation: 'Retry the scan',
        vulnerable: false
      };
    }
  }

  async checkSQLInjection(url) {
    try {
      const response = await axios.get(url);
      const content = response.data;
      
      // Get SQL injection patterns from AI service
      const sqlPatterns = aiService.getThreatPatterns('sql_injection');
      
      // Test common SQL injection points
      const testParams = {
        id: ["1'", "1 OR 1=1", "1; DROP TABLE users"],
        search: ["' OR '1'='1", "';--", "1' UNION SELECT"],
        username: ["admin'--", "admin' OR '1'='1"],
        password: ["' OR '1'='1", "';--"]
      };

      const findings = [];
      for (const [param, values] of Object.entries(testParams)) {
        for (const value of values) {
          try {
            const testResponse = await axios.get(url, {
              params: { [param]: value }
            });
            
            // Check for SQL error patterns in response
            if (this.containsSQLPatterns(testResponse.data, sqlPatterns)) {
              findings.push({
                parameter: param,
                payload: value,
                response: testResponse.data.substring(0, 200)
              });
            }
          } catch (error) {
            // Some errors might indicate SQL injection vulnerability
            if (error.response && this.containsSQLPatterns(error.response.data, sqlPatterns)) {
              findings.push({
                parameter: param,
                payload: value,
                error: error.response.data.substring(0, 200)
              });
            }
          }
        }
      }

      const result = {
        type: 'SQL Injection',
        severity: findings.length > 0 ? 'critical' : 'low',
        description: findings.length > 0 
          ? 'SQL injection vulnerability detected'
          : 'No obvious SQL injection vulnerabilities found',
        evidence: findings.length > 0 
          ? `Found ${findings.length} potential SQL injection points`
          : 'No suspicious patterns found',
        findings: findings,
        recommendation: 'Use parameterized queries and input validation',
        vulnerable: findings.length > 0
      };

      // Get AI analysis for SQL injection findings
      if (findings.length > 0) {
        result.aiAnalysis = await aiService.analyzeVulnerabilityPattern(
          JSON.stringify(findings),
          'SQL Injection'
        );
      }

      return result;
    } catch (error) {
      console.error('SQL injection check error:', error);
      return {
        type: 'SQL Injection',
        severity: 'unknown',
        description: 'Error during SQL injection check',
        evidence: error.message,
        recommendation: 'Retry the scan',
        vulnerable: false
      };
    }
  }

  async checkCSRFVulnerability(url) {
    try {
      const response = await axios.get(url);
      const content = response.data;
      
      // Check for CSRF tokens in forms
      const forms = this.extractForms(content);
      const findings = [];

      for (const form of forms) {
        const hasCSRFToken = form.includes('csrf') || 
                           form.includes('xsrf') || 
                           form.includes('_token');
        
        if (!hasCSRFToken) {
          findings.push({
            formAction: this.extractFormAction(form),
            method: this.extractFormMethod(form),
            missingProtection: true
          });
        }
      }

      const result = {
        type: 'CSRF',
        severity: findings.length > 0 ? 'high' : 'low',
        description: findings.length > 0 
          ? 'Potential CSRF vulnerability detected'
          : 'No obvious CSRF vulnerabilities found',
        evidence: findings.length > 0 
          ? `Found ${findings.length} forms without CSRF protection`
          : 'All forms appear to have CSRF protection',
        findings: findings,
        recommendation: 'Implement CSRF tokens and SameSite cookie attribute',
        vulnerable: findings.length > 0
      };

      // Get AI analysis for CSRF findings
      if (findings.length > 0) {
        result.aiAnalysis = await aiService.analyzeVulnerabilityPattern(
          JSON.stringify(findings),
          'CSRF'
        );
      }

      return result;
    } catch (error) {
      console.error('CSRF check error:', error);
      return {
        type: 'CSRF',
        severity: 'unknown',
        description: 'Error during CSRF check',
        evidence: error.message,
        recommendation: 'Retry the scan',
        vulnerable: false
      };
    }
  }

  async checkFileInclusion(url) {
    try {
      const response = await axios.get(url);
      const content = response.data;
      
      // Check for file inclusion patterns
      const filePatterns = [
        'include',
        'require',
        'file_get_contents',
        'fopen',
        'readfile'
      ];

      const findings = [];
      for (const pattern of filePatterns) {
        const matches = content.match(new RegExp(pattern + '\\s*\\([^)]+\\)', 'g'));
        if (matches) {
          findings.push({
            pattern: pattern,
            matches: matches
          });
        }
      }

      const result = {
        type: 'File Inclusion',
        severity: findings.length > 0 ? 'high' : 'low',
        description: findings.length > 0 
          ? 'Potential file inclusion vulnerability detected'
          : 'No obvious file inclusion vulnerabilities found',
        evidence: findings.length > 0 
          ? `Found ${findings.length} potential file inclusion patterns`
          : 'No suspicious patterns found',
        findings: findings,
        recommendation: 'Implement strict file path validation',
        vulnerable: findings.length > 0
      };

      // Get AI analysis for file inclusion findings
      if (findings.length > 0) {
        result.aiAnalysis = await aiService.analyzeVulnerabilityPattern(
          JSON.stringify(findings),
          'File Inclusion'
        );
      }

      return result;
    } catch (error) {
      console.error('File inclusion check error:', error);
      return {
        type: 'File Inclusion',
        severity: 'unknown',
        description: 'Error during file inclusion check',
        evidence: error.message,
        recommendation: 'Retry the scan',
        vulnerable: false
      };
    }
  }

  // Helper methods
  containsSQLPatterns(content, patterns) {
    return patterns.some(pattern => 
      content.toLowerCase().includes(pattern.toLowerCase())
    );
  }

  extractForms(content) {
    const formRegex = /<form[^>]*>[\s\S]*?<\/form>/gi;
    return content.match(formRegex) || [];
  }

  extractFormAction(form) {
    const actionMatch = form.match(/action=["']([^"']+)["']/i);
    return actionMatch ? actionMatch[1] : '';
  }

  extractFormMethod(form) {
    const methodMatch = form.match(/method=["']([^"']+)["']/i);
    return methodMatch ? methodMatch[1].toUpperCase() : 'GET';
  }

  async checkCommandInjection(url) {
    // Simulate command injection check
    return {
      type: 'Command Injection',
      severity: 'critical',
      description: 'Possible command injection vulnerability detected',
      evidence: 'Found unvalidated command parameters',
      recommendation: 'Use safe APIs and input validation'
    };
  }

  async checkXXEVulnerability(url) {
    // Simulate XXE check
    return {
      type: 'XXE',
      severity: 'high',
      description: 'Possible XML External Entity vulnerability detected',
      evidence: 'Found XML parsing without proper configuration',
      recommendation: 'Disable external entity processing in XML parser'
    };
  }
}

module.exports = new VulnerabilityScanner(); 